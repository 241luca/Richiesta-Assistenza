// METODI AGGIUNTIVI PER DASHBOARD PAGAMENTI
// Da aggiungere al file payment.service.ts prima dell'export finale

import { subMonths, addDays, format } from 'date-fns';

// Aggiungi questi metodi nella classe PaymentService:

  /**
   * Ottiene lista pagamenti con filtri (metodo esistente da correggere)
   */
  async getPayments(filters: any = {}) {
    try {
      const where: any = {};
      
      // Filtri data
      if (filters.from || filters.to) {
        where.createdAt = {};
        if (filters.from) where.createdAt.gte = new Date(filters.from);
        if (filters.to) where.createdAt.lte = new Date(filters.to);
      }
      
      // Filtro stato
      if (filters.status && filters.status !== '') {
        where.status = filters.status;
      }
      
      // Filtro tipo
      if (filters.type && filters.type !== '') {
        where.type = filters.type;
      }
      
      // Ricerca testuale
      if (filters.searchTerm && filters.searchTerm !== '') {
        where.OR = [
          { transactionId: { contains: filters.searchTerm } },
          { stripePaymentId: { contains: filters.searchTerm } },
          { user: { 
            OR: [
              { email: { contains: filters.searchTerm } },
              { firstName: { contains: filters.searchTerm } },
              { lastName: { contains: filters.searchTerm } }
            ]
          }}
        ];
      }

      const payments = await prisma.payment.findMany({
        where,
        include: {
          user: true,
          quote: {
            include: {
              request: true
            }
          }
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: filters.limit || 100
      });

      return payments;
    } catch (error) {
      logger.error('Error getting payments:', error);
      throw error;
    }
  }

  /**
   * Statistiche admin dashboard
   */
  async getAdminStats(filters: { startDate?: Date; endDate?: Date }) {
    try {
      const { startDate = subMonths(new Date(), 1), endDate = new Date() } = filters;

      // Query aggregata per statistiche
      const [payments, refunds] = await Promise.all([
        prisma.payment.findMany({
          where: {
            createdAt: {
              gte: startDate,
              lte: endDate
            }
          },
          include: {
            user: true,
            quote: {
              include: {
                request: true
              }
            }
          }
        }),
        prisma.refund.findMany({
          where: {
            createdAt: {
              gte: startDate,
              lte: endDate
            }
          }
        })
      ]);

      // Calcola statistiche
      const totalRevenue = payments
        .filter(p => p.status === 'COMPLETED')
        .reduce((sum, p) => sum + p.amount, 0);

      const totalTransactions = payments.length;
      const completedTransactions = payments.filter(p => p.status === 'COMPLETED').length;
      const successRate = totalTransactions > 0 ? (completedTransactions / totalTransactions) * 100 : 0;

      const pendingAmount = payments
        .filter(p => p.status === 'PENDING')
        .reduce((sum, p) => sum + p.amount, 0);

      const refundedAmount = refunds
        .filter(r => r.status === 'COMPLETED')
        .reduce((sum, r) => sum + r.amount, 0);

      // Calcolo crescita mensile
      const previousMonth = await prisma.payment.aggregate({
        where: {
          status: 'COMPLETED',
          createdAt: {
            gte: subMonths(startDate, 1),
            lt: startDate
          }
        },
        _sum: {
          amount: true
        }
      });

      const previousRevenue = previousMonth._sum.amount || 0;
      const monthlyGrowth = previousRevenue > 0 
        ? ((totalRevenue - previousRevenue) / previousRevenue) * 100 
        : 0;

      // Statistiche per stato
      const byStatus: Record<string, { count: number; amount: number }> = {};
      for (const payment of payments) {
        if (!byStatus[payment.status]) {
          byStatus[payment.status] = { count: 0, amount: 0 };
        }
        byStatus[payment.status].count++;
        byStatus[payment.status].amount += payment.amount;
      }

      // Statistiche per tipo
      const byType: Record<string, { count: number; amount: number }> = {};
      for (const payment of payments) {
        if (!byType[payment.type]) {
          byType[payment.type] = { count: 0, amount: 0 };
        }
        byType[payment.type].count++;
        byType[payment.type].amount += payment.amount;
      }

      return {
        totalRevenue,
        totalTransactions,
        averageTransaction: totalTransactions > 0 ? totalRevenue / completedTransactions : 0,
        successRate,
        pendingAmount,
        refundedAmount,
        monthlyGrowth,
        topPaymentMethod: 'CARD',
        byStatus,
        byType,
        recentPayments: payments.slice(0, 10)
      };
    } catch (error) {
      logger.error('Error getting admin stats:', error);
      throw error;
    }
  }

  /**
   * Altri metodi per Professional dashboard...
   */
