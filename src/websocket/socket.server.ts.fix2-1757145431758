/**
 * WebSocket Server Configuration
 * Gestisce tutte le connessioni real-time con autenticazione JWT
 */

import { Server, Socket } from 'socket.io';
import jwt from 'jsonwebtoken';
import { logger } from '../utils/logger';
import { PrismaClient } from '@prisma/client';
import { 
  handleNotificationEvents,
  handleRequestEvents,
  handleQuoteEvents,
  handleMessageEvents 
} from './handlers';
import { chatService } from '../services/chat.service';

const prisma = new PrismaClient();

interface AuthenticatedSocket extends Socket {
  userId?: string;
  userRole?: string;
}

// Map per tracciare le connessioni utente
const userSockets = new Map<string, Set<string>>();

/**
 * Middleware di autenticazione per Socket.io
 */
async function authenticateSocket(socket: AuthenticatedSocket, next: (err?: Error) => void) {
  try {
    // Prova a prendere il token da varie fonti
    const token = socket.handshake.auth.token || 
                  socket.handshake.headers.authorization?.replace('Bearer ', '') ||
                  socket.handshake.query.token;
    
    logger.debug(`WebSocket auth attempt - Token present: ${!!token}`);
    
    if (!token) {
      logger.error('WebSocket auth failed: No token provided');
      return next(new Error('Authentication token missing'));
    }

    // Verifica JWT con il secret corretto
    const jwtSecret = process.env.JWT_SECRET;
    if (!jwtSecret) {
      logger.error('JWT_SECRET not configured!');
      return next(new Error('Server configuration error'));
    }
    
    const decoded = jwt.verify(token, jwtSecret) as any;
    logger.debug(`Token decoded successfully for User: ${decoded.userId}`);
    
    // Carica dati utente dal database
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: {
        id: true,
        role: true,
        email: true
      }
    });

    if (!user) {
      logger.error(`User not found for ID: ${decoded.userId}`);
      return next(new Error('User not found'));
    }

    // Assegna dati al socket
    socket.userId = user.id;
    socket.userRole = user.role;

    logger.info(`User ${user.email} authenticated via WebSocket`);
    next();
  } catch (error) {
    logger.error('Socket authentication error:', error);
    next(new Error('Authentication failed'));
  }
}

/**
 * Inizializza il server WebSocket con tutti gli handler
 */
export function initializeSocketServer(io: Server) {
  // Applica middleware di autenticazione
  io.use(authenticateSocket);

  io.on('connection', (socket: AuthenticatedSocket) => {
    if (!socket.userId) {
      logger.error('Socket connection rejected: No userId');
      socket.disconnect();
      return;
    }

    logger.info(`✅ Client connected: ${socket.id} (User: ${socket.userId})`);

    // Aggiungi socket alla mappa utente
    if (!userSockets.has(socket.userId)) {
      userSockets.set(socket.userId, new Set());
    }
    userSockets.get(socket.userId)?.add(socket.id);

    // Join automatico alle room appropriate
    // Room utente personale
    socket.join(`User:${socket.userId}`);
    
    // Room per ruolo
    socket.join(`role:${socket.userRole}`);
    
    // Room broadcast globale (per tutti gli utenti)
    socket.join('broadcast:all');

    // Notifica connessione avvenuta
    socket.emit('connected', {
      userId: socket.userId,
      role: socket.userRole,
      socketId: socket.id,
      timestamp: new Date()
    });
    
    logger.info(`WebSocket authenticated - User: ${socket.userId}, Role: ${socket.userRole}`);

    // Registra gli handler per i vari eventi
    handleNotificationEvents(socket as any, io);
    handleRequestEvents(socket as any, io);
    handleQuoteEvents(socket as any, io);
    handleMessageEvents(socket as any, io);
    
    // Handler per eventi della chat delle richieste
    handleChatEvents(socket as any, io);

    // Handler per ping/pong (keepalive)
    socket.on('ping', () => {
      socket.emit('pong', { timestamp: Date.now() });
    });

    // Handler per cambio status utente
    socket.on('User:status', async (status: 'online' | 'away' | 'busy' | 'offline') => {
      try {
        // Aggiorna status nel database
        await prisma.user.update({
          where: { id: socket.userId },
          data: { 
            status,
            lastSeenAt: new Date()
          }
        });

        // Notifica tutti gli altri utenti
        socket.to('broadcast:all').emit('User:status:changed', {
          userId: socket.userId,
          status,
          timestamp: new Date()
        });

        logger.debug(`User ${socket.userId} status changed to ${status}`);
      } catch (error) {
        logger.error('Error updating user status:', error);
        socket.emit('error', { message: 'Failed to update status' });
      }
    });

    // Handler per sottoscrizione a canali specifici
    socket.on('subscribe', (channels: string[]) => {
      channels.forEach(channel => {
        // Verifica autorizzazioni per il canale
        if (isAuthorizedForChannel(socket, channel)) {
          socket.join(channel);
          logger.debug(`Socket ${socket.id} subscribed to ${channel}`);
        }
      });
    });

    // Handler per disconnessione
    socket.on('disconnect', async (reason) => {
      logger.info(`❌ Client disconnected: ${socket.id} (Reason: ${reason})`);
      
      // Rimuovi dalla mappa utente
      if (socket.userId) {
        const sockets = userSockets.get(socket.userId);
        if (sockets) {
          sockets.delete(socket.id);
          if (sockets.size === 0) {
            userSockets.delete(socket.userId);
            
            // Utente completamente offline - aggiorna lastSeenAt
            try {
              await prisma.user.update({
                where: { id: socket.userId },
                data: { 
                  status: 'offline',
                  lastSeenAt: new Date()
                }
              });

              // Notifica tutti gli altri utenti
              io.to('broadcast:all').emit('User:offline', {
                userId: socket.userId,
                timestamp: new Date()
              });
            } catch (error) {
              logger.error('Error updating user offline status:', error);
            }
          }
        }
      }
    });

    // Handler per errori
    socket.on('error', (error) => {
      logger.error(`Socket error for ${socket.id}:`, error);
    });
  });

  // Log server WebSocket pronto
  logger.info('🚀 WebSocket server initialized with authentication');
}

/**
 * Verifica se un socket è autorizzato per un canale specifico
 */
function isAuthorizedForChannel(socket: AuthenticatedSocket, channel: string): boolean {
  // Canali broadcast pubblici
  if (channel.startsWith('broadcast:')) {
    return true;
  }

  // Canali privati utente
  if (channel.startsWith(`User:${socket.userId}:`)) {
    return true;
  }

  // Canali admin (solo per ruoli admin)
  if (channel.startsWith('admin:') && ['ADMIN', 'SUPER_ADMIN'].includes(socket.userRole || '')) {
    return true;
  }

  // Canali professionisti (solo per professionisti)
  if (channel.startsWith('Professional:') && socket.userRole === 'PROFESSIONAL') {
    return true;
  }

  return false;
}

/**
 * Funzione helper per inviare notifiche a un utente specifico
 */
export function sendToUser(io: Server, userId: string, event: string, data: any) {
  io.to(`User:${userId}`).emit(event, {
    ...data,
    timestamp: new Date()
  });
}

/**
 * Funzione helper per broadcast a tutti gli utenti
 */
export function broadcastToAll(io: Server, event: string, data: any) {
  io.to('broadcast:all').emit(event, {
    ...data,
    timestamp: new Date()
  });
}

/**
 * Funzione helper per verificare se un utente è online
 */
export function isUserOnline(userId: string): boolean {
  return userSockets.has(userId);
}

/**
 * Funzione helper per ottenere tutti i socket di un utente
 */
export function getUserSockets(userId: string): Set<string> | undefined {
  return userSockets.get(userId);
}

/**
 * Handler per gli eventi della chat delle richieste
 */
function handleChatEvents(socket: AuthenticatedSocket, io: Server) {
  // Join a una chat room specifica per la richiesta
  socket.on('chat:join-request', async (requestId: string) => {
    try {
      if (!socket.userId) return;

      // Verifica se l'utente può accedere alla chat
      const canAccess = await chatService.canAccessChat(socket.userId, requestId);
      if (!canAccess) {
        socket.emit('chat:error', { message: 'Non hai accesso a questa chat' });
        return;
      }

      // Unisciti alla room della richiesta
      socket.join(`chat:request:${requestId}`);
      logger.info(`User ${socket.userId} joined chat room for request ${requestId}`);

      // Invia i messaggi iniziali
      const messages = await chatService.getMessages(requestId, socket.userId);
      socket.emit('chat:initial-messages', messages);

      // Notifica agli altri che l'utente è online nella chat
      socket.to(`chat:request:${requestId}`).emit('chat:user-joined', {
        userId: socket.userId,
        timestamp: new Date()
      });
    } catch (error) {
      logger.error('Error joining chat room:', error);
      socket.emit('chat:error', { message: 'Errore nell\'accesso alla chat' });
    }
  });

  // Lascia una chat room
  socket.on('chat:leave-request', (requestId: string) => {
    socket.leave(`chat:request:${requestId}`);
    logger.info(`User ${socket.userId} left chat room for request ${requestId}`);

    // Notifica agli altri che l'utente ha lasciato la chat
    socket.to(`chat:request:${requestId}`).emit('chat:user-left', {
      userId: socket.userId,
      timestamp: new Date()
    });
  });

  // Invia un messaggio
  socket.on('chat:send-message', async (data: {
    requestId: string;
    message: string;
    messageType?: string;
    attachments?: any[];
  }) => {
    try {
      if (!socket.userId) return;

      // Invia il messaggio tramite il service
      const newMessage = await chatService.sendMessage({
        requestId: data.requestId,
        userId: socket.userId,
        message: data.message,
        messageType: data.messageType as any,
        attachments: data.attachments
      });

      // Invia il messaggio a tutti nella room (incluso il mittente)
      io.to(`chat:request:${data.requestId}`).emit('chat:new-message', newMessage);
    } catch (error: any) {
      logger.error('Error sending message via WebSocket:', error);
      socket.emit('chat:error', { message: error.message || 'Errore nell\'invio del messaggio' });
    }
  });

  // Modifica un messaggio
  socket.on('chat:edit-message', async (data: {
    messageId: string;
    requestId: string;
    message: string;
  }) => {
    try {
      if (!socket.userId) return;

      const updatedMessage = await chatService.updateMessage(
        data.messageId,
        socket.userId,
        { message: data.message }
      );

      // Notifica tutti nella room della modifica
      io.to(`chat:request:${data.requestId}`).emit('chat:message-edited', updatedMessage);
    } catch (error: any) {
      logger.error('Error editing message via WebSocket:', error);
      socket.emit('chat:error', { message: error.message || 'Errore nella modifica del messaggio' });
    }
  });

  // Elimina un messaggio
  socket.on('chat:delete-message', async (data: {
    messageId: string;
    requestId: string;
  }) => {
    try {
      if (!socket.userId) return;

      await chatService.deleteMessage(data.messageId, socket.userId);

      // Notifica tutti nella room dell'eliminazione
      io.to(`chat:request:${data.requestId}`).emit('chat:message-deleted', {
        messageId: data.messageId,
        deletedBy: socket.userId,
        timestamp: new Date()
      });
    } catch (error: any) {
      logger.error('Error deleting message via WebSocket:', error);
      socket.emit('chat:error', { message: error.message || 'Errore nell\'eliminazione del messaggio' });
    }
  });

  // Indicatore di digitazione
  socket.on('chat:typing', (data: { requestId: string; isTyping: boolean }) => {
    socket.to(`chat:request:${data.requestId}`).emit('chat:user-typing', {
      userId: socket.userId,
      isTyping: data.isTyping,
      timestamp: new Date()
    });
  });

  // Segna messaggi come letti
  socket.on('chat:mark-as-read', async (data: { requestId: string }) => {
    try {
      if (!socket.userId) return;

      await chatService.markMessagesAsRead(data.requestId, socket.userId);

      // Notifica il mittente che i suoi messaggi sono stati letti
      socket.to(`chat:request:${data.requestId}`).emit('chat:messages-read', {
        readBy: socket.userId,
        requestId: data.requestId,
        timestamp: new Date()
      });
    } catch (error) {
      logger.error('Error marking messages as read via WebSocket:', error);
    }
  });
}

export default {
  initializeSocketServer,
  sendToUser,
  broadcastToAll,
  isUserOnline,
  getUserSockets
};
