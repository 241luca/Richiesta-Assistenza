/**
 * Notification Event Handlers
 * Gestisce tutti gli eventi relativi alle notifiche real-time
 */

import { Server } from 'socket.io';
import { PrismaClient } from '@prisma/client';
import { logger } from '../../utils/logger';

const prisma = new PrismaClient();

interface AuthenticatedSocket {
  id: string;
  userId?: string;
  userRole?: string;
  emit: (event: string, data: any) => void;
  join: (room: string) => void;
  to: (room: string) => any;
  on: (event: string, callback: (...args: any[]) => void) => void;
}

export function handleNotificationEvents(socket: AuthenticatedSocket, io: Server) {
  /**
   * Recupera tutte le notifiche non lette dell'utente
   */
  socket.on('notification:getUnread', async () => {
    try {
      const notifications = await prisma.notification.findMany({
        where: {
          userId: socket.userId!,
          isRead: false
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 50
      });

      socket.emit('notification:unreadList', {
        notifications,
        count: notifications.length
      });
    } catch (error) {
      logger.error('Error fetching unread notifications:', error);
      socket.emit('error', { message: 'Failed to fetch notifications' });
    }
  });

  /**
   * Segna una notifica come letta
   */
  socket.on('notification:markAsRead', async (notificationId: string) => {
    try {
      const notification = await prisma.notification.findFirst({
        where: {
          id: notificationId,
          userId: socket.userId!
        }
      });

      if (!notification) {
        throw new Error('Notification not found');
      }

      await prisma.notification.update({
        where: { id: notificationId },
        data: { 
          isRead: true, 
          readAt: new Date() 
        }
      });

      socket.emit('notification:marked', { 
        id: notificationId, 
        isRead: true 
      });

      // Aggiorna il contatore
      const unreadCount = await prisma.notification.count({
        where: {
          userId: socket.userId!,
          isRead: false
        }
      });

      socket.emit('notification:unreadCount', { count: unreadCount });
    } catch (error) {
      logger.error('Error marking notification as read:', error);
      socket.emit('error', { message: 'Failed to mark notification as read' });
    }
  });

  /**
   * Segna tutte le notifiche come lette
   */
  socket.on('notification:markAllAsRead', async () => {
    try {
      await prisma.notification.updateMany({
        where: {
          userId: socket.userId!,
          isRead: false
        },
        data: { 
          isRead: true, 
          readAt: new Date() 
        }
      });

      socket.emit('notification:allMarked', { success: true });
      socket.emit('notification:unreadCount', { count: 0 });
    } catch (error) {
      logger.error('Error marking all notifications as read:', error);
      socket.emit('error', { message: 'Failed to mark all notifications as read' });
    }
  });

  /**
   * Elimina una notifica
   */
  socket.on('notification:delete', async (notificationId: string) => {
    try {
      const notification = await prisma.notification.findFirst({
        where: {
          id: notificationId,
          userId: socket.userId!
        }
      });

      if (!notification) {
        throw new Error('Notification not found');
      }

      await prisma.notification.delete({
        where: { id: notificationId }
      });

      socket.emit('notification:deleted', { id: notificationId });

      // Aggiorna il contatore
      const unreadCount = await prisma.notification.count({
        where: {
          userId: socket.userId!,
          isRead: false
        }
      });

      socket.emit('notification:unreadCount', { count: unreadCount });
    } catch (error) {
      logger.error('Error deleting notification:', error);
      socket.emit('error', { message: 'Failed to delete notification' });
    }
  });

  /**
   * Recupera le preferenze di notifica dell'utente
   */
  socket.on('notification:getPreferences', async () => {
    try {
      const preferences = await prisma.notificationPreference.findUnique({
        where: { userId: socket.userId! }
      });

      socket.emit('notification:preferences', preferences || {
        email: true,
        push: true,
        sms: false,
        inApp: true
      });
    } catch (error) {
      logger.error('Error fetching notification preferences:', error);
      socket.emit('error', { message: 'Failed to fetch preferences' });
    }
  });

  /**
   * Aggiorna le preferenze di notifica
   */
  socket.on('notification:updatePreferences', async (preferences: any) => {
    try {
      const updated = await prisma.notificationPreference.upsert({
        where: { userId: socket.userId! },
        update: preferences,
        create: {
          userId: socket.userId!,
          ...preferences
        }
      });

      socket.emit('notification:preferencesUpdated', updated);
    } catch (error) {
      logger.error('Error updating notification preferences:', error);
      socket.emit('error', { message: 'Failed to update preferences' });
    }
  });
}

/**
 * Invia una notifica real-time a un utente specifico
 */
export async function sendNotificationToUser(
  io: Server,
  userId: string,
  notification: {
    type: string;
    title: string;
    message: string;
    data?: any;
    priority?: 'low' | 'normal' | 'high' | 'urgent';
  }
) {
  try {
    // Salva nel database
    const saved = await prisma.notification.create({
      data: {
        userId,
        type: notification.type,
        title: notification.title,
        message: notification.message,
        data: notification.data || {},
        priority: notification.priority || 'normal',
        isRead: false
      }
    });

    // Invia via WebSocket se l'utente Ã¨ online
    io.to(`User:${userId}`).emit('notification:new', {
      ...saved,
      timestamp: new Date()
    });

    // Aggiorna il contatore
    const unreadCount = await prisma.notification.count({
      where: {
        userId,
        isRead: false
      }
    });

    io.to(`User:${userId}`).emit('notification:unreadCount', { count: unreadCount });

    logger.info(`Notification sent to user ${userId}: ${notification.title}`);
    return saved;
  } catch (error) {
    logger.error('Error sending notification:', error);
    throw error;
  }
}

/**
 * Invia una notifica a tutti gli utenti di un'organizzazione
 */
export async function broadcastNotificationToOrganization(
  io: Server,
  notification: {
    type: string;
    title: string;
    message: string;
    data?: any;
    priority?: 'low' | 'normal' | 'high' | 'urgent';
  }
) {
  try {
    // Trova tutti gli utenti dell'organizzazione
    const users = await prisma.user.findMany({
      select: { id: true }
    });

    // Crea notifiche per tutti gli utenti
    const notifications = await prisma.notification.createMany({
      data: users.map(user => ({
        userId: user.id,
        type: notification.type,
        title: notification.title,
        message: notification.message,
        data: notification.data || {},
        priority: notification.priority || 'normal',
        isRead: false
      }))
    });

    // Broadcast via WebSocket
    io.emit('notification:new', {
      ...notification,
      timestamp: new Date()
    });

    return notifications;
  } catch (error) {
    logger.error('Error broadcasting notification:', error);
    throw error;
  }
}
