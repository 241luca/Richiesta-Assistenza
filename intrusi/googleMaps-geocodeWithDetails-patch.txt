// Aggiungi questo metodo alla classe GoogleMapsService
// Inserire dopo il metodo geocode() intorno alla riga 300

  /**
   * Geocoding con dettagli completi dei componenti dell'indirizzo
   * @param address L'indirizzo da geocodificare
   * @returns Oggetto con coordinate e componenti dettagliati dell'indirizzo
   */
  static async geocodeWithDetails(address: string): Promise<{
    location: { lat: number; lng: number } | null;
    formattedAddress: string | null;
    components: {
      streetNumber?: string;
      route?: string;
      locality?: string;
      administrativeAreaLevel2?: string;
      administrativeAreaLevel1?: string;
      country?: string;
      postalCode?: string;
    } | null;
  } | null> {
    try {
      const apiKey = await this.getApiKey();
      
      if (!apiKey) {
        logger.warn('Google Maps API key not configured');
        return null;
      }

      // Controlla cache
      const cacheKey = `geocode:${address}`;
      const cached = this.geocodeCache.get(cacheKey);
      
      if (cached && this.isCacheValid(cached.timestamp)) {
        return cached.data;
      }

      // Chiama Google Geocoding API
      const url = `https://maps.googleapis.com/maps/api/geocode/json`;
      const params = new URLSearchParams({
        address: address,
        key: apiKey,
        language: 'it',
        region: 'IT'
      });

      const response = await fetch(`${url}?${params}`);
      const data = await response.json();

      if (data.status !== 'OK' || !data.results || data.results.length === 0) {
        logger.warn(`Geocoding failed for address: ${address}`, data.status);
        return null;
      }

      const result = data.results[0];
      const location = result.geometry.location;
      
      // Estrai componenti dell'indirizzo
      const components: any = {};
      
      for (const component of result.address_components) {
        const types = component.types;
        
        if (types.includes('street_number')) {
          components.streetNumber = component.long_name;
        }
        if (types.includes('route')) {
          components.route = component.long_name;
        }
        if (types.includes('locality')) {
          components.locality = component.long_name;
        }
        if (types.includes('administrative_area_level_2')) {
          components.administrativeAreaLevel2 = component.long_name;
        }
        if (types.includes('administrative_area_level_1')) {
          components.administrativeAreaLevel1 = component.long_name;
        }
        if (types.includes('country')) {
          components.country = component.long_name;
        }
        if (types.includes('postal_code')) {
          components.postalCode = component.long_name;
        }
      }

      const detailedResult = {
        location: {
          lat: location.lat,
          lng: location.lng
        },
        formattedAddress: result.formatted_address,
        components
      };

      // Salva in cache
      this.geocodeCache.set(cacheKey, {
        data: detailedResult,
        timestamp: Date.now()
      });

      logger.info(`Geocoded with details: ${address} -> ${result.formatted_address}`);
      return detailedResult;

    } catch (error) {
      logger.error('Geocoding with details error:', error);
      return null;
    }
  }
